# [16198번: 에너지 모으기](https://www.acmicpc.net/problem/16198)

N개의 에너지 구슬이 일렬로 놓여져 있고, 에너지 구슬을 이용해서 에너지를 모으려고 한다.

i번째 에너지 구슬의 무게는 W<sub>i</sub>이고, 에너지를 모으는 방법은 다음과 같으며, 반복해서 사용할 수 있다.

1. 에너지 구슬 하나를 고른다. 고른 에너지 구슬의 번호를 x라고 한다. 단, 첫 번째와 마지막 에너지 구슬은 고를 수 없다.
2. x번째 에너지 구슬을 제거한다.
3. W<sub>x-1</sub> × W<sub>x+1</sub>의 에너지를 모을 수 있다.
4. N을 1 감소시키고, 에너지 구슬을 1번부터 N번까지로 다시 번호를 매긴다. 번호는 첫 구슬이 1번, 다음 구슬이 2번, ... 과 같이 매겨야 한다.

N과 에너지 구슬의 무게가 주어졌을 때, 모을 수 있는 에너지 양의 최댓값을 구하는 프로그램을 작성하시오.

## 입출력

### 입력

첫째 줄에 에너지 구슬의 개수 N(3 ≤ N ≤ 10)이 주어진다.

둘째 줄에는 에너지 구슬의 무게 W1, W2, ..., WN을 공백으로 구분해 주어진다. (1 ≤ Wi ≤ 1,000)

### 출력

첫째 줄에 모을 수 있는 에너지의 최댓값을 출력한다.

## 예제

### 예제 입력 1

```text
4
1 2 3 4
```

### 예제 출력 1

```text
12
```

### 예제 입력 2

```text
5
100 2 1 3 100
```

### 예제 출력 2

```text
10400
```

### 예제 입력 3

```text
7
2 2 7 6 90 5 9
```

### 예제 출력 3

```text
1818
```

### 예제 입력 4

```text
10
1 1 1 1 1 1 1 1 1 1
```

### 예제 출력 4

```text
8
```

## 알고리즘 분류

- 브루트포스 알고리즘
- 백트래킹

## 시도

### 시도1(32412kb, 84ms)

처음에는 문제 이해가 잘 안 됐지만, 여러번 반복해서 읽고 입력에 대한 결과를 출력과 비교하며 이해했다.

1. 첫 번째 구술과 마지막 구슬을 제외한 구슬을 고른다.
2. 해당 구슬의 양 옆에 있는 구슬의 값들을 곱해서 더해나간다.
3. 뽑았던 구슬을 제외하고, 1번부터 다시 반복해 나가며 최댓값을 가질 수 있는 값을 출력한다.

해당 문제애 대해 조합으로 완전 탐색으로 풀 수도 있을 것 같지만, 나는 `back tracking`을 이용하여 문제를 해결하였다.

```python
# https://www.acmicpc.net/problem/16198
# 에너지 모으기
import sys

input = sys.stdin.readline

N = int(input())
number = list(map(int, input().split()))


# N = 4
# number = [1, 2, 3, 4]
# N = 5
# number = [100, 2, 1, 3, 100]


def back_tracking(arr, result):
    global answer

    if len(arr) == 2:  # 가운데를 뽑을 수 없을 때
        answer = max(answer, result)  # 기존에 있던 값과 계속 더해왔던 값의 최댓값을 구한다.
        return

    for i in range(1, len(arr) - 1):  # 양 옆의 구슬을 선택할 수 없으니, 1~전체 크기의 -1까지 탐색한다.
        current = result + arr[i - 1] * arr[i + 1]  # 현재 선택한 구슬의 업데이트된 값
        temp = arr.pop(i)  # 현재 구슬을 선택하였으니 제거한다.
        back_tracking(arr, current)  # 재귀로 반복
        arr.insert(i, temp)  # 모든 선택을 한 후에 다시 추가한다.


answer = 0
back_tracking(number, 0)
print(answer)
```