# [14940번: 쉬운 최단거리](https://www.acmicpc.net/problem/14940)

지도가 주어지면 모든 지점에 대해서 목표지점까지의 거리를 구하여라.

문제를 쉽게 만들기 위해 오직 가로와 세로로만 움직일 수 있다고 하자.

## 입출력

### 입력
지도의 크기 n과 m이 주어진다. n은 세로의 크기, m은 가로의 크기다.(2 ≤ n ≤ 1000, 2 ≤ m ≤ 1000)

다음 n개의 줄에 m개의 숫자가 주어진다. 0은 갈 수 없는 땅이고 1은 갈 수 있는 땅, 2는 목표지점이다. 입력에서 2는 단 한개이다.

### 출력
각 지점에서 목표지점까지의 거리를 출력한다. 원래 갈 수 없는 땅인 위치는 0을 출력하고, 원래 갈 수 있는 땅인 부분 중에서 도달할 수 없는 위치는 -1을 출력한다.

## 예제

### 예제 입력 1

```text
15 15
2 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 0 0 0 0 1
1 1 1 1 1 1 1 1 1 1 0 1 1 1 1
1 1 1 1 1 1 1 1 1 1 0 1 0 0 0
1 1 1 1 1 1 1 1 1 1 0 1 1 1 1
```

### 예제 출력 1

```text
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
7 8 9 10 11 12 13 14 15 16 17 18 19 20 21
8 9 10 11 12 13 14 15 16 17 18 19 20 21 22
9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
11 12 13 14 15 16 17 18 19 20 0 0 0 0 25
12 13 14 15 16 17 18 19 20 21 0 29 28 27 26
13 14 15 16 17 18 19 20 21 22 0 30 0 0 0
14 15 16 17 18 19 20 21 22 23 0 31 32 33 34
```

## 알고리즘 분류

- 그래프 이론
- 그래프 탐색
- 너비 우선 탐색
- 격자 그래프

## 시도

### 시도1(43656kb, 732ms)

그래프를 쳐다보며, 어떻게 풀지 하다가 각 인덱스에서 2를 찾아 탐색하는 걸 생각해봤다.

하지만, 모든 인덱스에서 2를 접근하는 건 시간도 오래 걸릴 뿐만 아니라, 장애물도 있는 상황에서 정확히 2가 있는 위치를 찾아가기란 쉽지 않았다.
(속으로 쉬운 최단거리가 아니라 어려운 최단거리라고 생각함 ,,)

계속 고민하던 찰나에 출력을 보니 0에서부터 1씩 증가하는 걸 볼 수 있었고, 2에서부터 다른 인덱스를 접근하면 되겠다고 생각했다.

대각선으로 계속해서 값들이 퍼지기때문에, `dfs`보다는 `bfs`가 더 잘 맞는다고 생각하여 bfs를 이용하여 문제를 해결했다.

```python
import sys
from collections import deque

input = sys.stdin.readline

DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]

N, M = map(int, input().split())
graphs = [list(map(int, input().split())) for _ in range(N)]

visited = [[False] * M for _ in range(N)]
need_visited = deque()
destination = ()
for row in range(N):
    if 2 not in graphs[row]:
        continue
    col = graphs[row].index(2)
    need_visited.append((row, col))
    visited[row][col] = True
    break

answers = [[0] * M for _ in range(N)]
while need_visited:
    x, y = need_visited.popleft()

    for dx, dy in DIRECTIONS:
        r, c = x + dx, y + dy

        if 0 <= r < N and 0 <= c < M and not visited[r][c] and graphs[r][c] == 1:
            need_visited.append((r, c))
            answers[r][c] = answers[x][y] + 1
            visited[r][c] = True

for i in range(N):
    for j in range(M):
        if graphs[i][j] == 0 or visited[i][j]:
            print(answers[i][j], end=' ')
        else:
            print(-1, end=' ')
    print()
```

## 정리

